### AmbientRecordingApp API

The API for AmbientRecordingApp! This specifies contract between client and server.

Clients can create, read, modify, and delete appointments with the endpoints defined here. Recordings can be created with audio data and later queried.

### Motivation

We want a reliable and familiar interface for syncing data bi-directionally between client and server. This project needs to be finished with limited time and should be simple but robust.

### Endpoints

* [**Create Appointment**](./appointments-create.md)
* [**Query Appointments**](./appointments-query.md)
* [**Read/Update/Delete Appointment**](./appointment-action.md)
* [**Create Recording**](./recordings-create.md)
* [**Query Recordings**](./recordings-query.md)

### Entity Definitions

Recording
- `id` (String): unique identifier for entity (generated by server)
- `etag` (String): opaque version tag (generated by server)
- `appointment_id` (String): unique identifier for parent entity
- `start` (String): time when recording began, ISO 8601 Date string
- `end` (String): time when recording ended, ISO 8601 Date string
- `duration` (Number): duration of recording, in seconds
- `streaming_url` (String): URL where audio data can be downloaded (generated by server)

Appointment
- `id` (String): unique identifier for entity (generated by server)
- `etag` (String): opaque version tag (generated by server)
- `scheduled_start` (String): expected start time, ISO 8601 Date string
- `scheduled_end` (String): expected end time, ISO 8601 Date string
- `patient_name` (String): name of patient who is the focus of appointment
- `notes` (String): any additional notes

### Patterns

Endpoints mostly follow REST patterns with JSON payloads.

Dates are specified in [ISO 8601](http://en.wikipedia.org/wiki/ISO_8601) strings.

In POST and PUT requests, JSON entity items are each identified with a `client_id`, in order to allow server to generate unique identifiers for new entities, and to associate errors in responses.

The endpoints are versioned for backwards compatibility: once clients are shipped to customers with a particular API version, we should not change it without breaking them. New API versions can be changed for new clients without breaking support for existing customers.

Query endpoints can be paginated in order to scale with more data. These endpoints may accept optional `count` and `page` parameters used to navigate through pages of entities. In order to prevent missing data when changes occur in between requests for pages, we use a `ctag` field to version paged queries.

Data loss from conflicts is avoided by versioning entities with etags, so that different clients cannot overwrite data unexpectedly. Each entity has an `etag` opaque value which is provided by server and specifies entity version saved to database. Updates to entities are rejected if `etag` is not up-to-date, and requests can be tried again.

### Handling Failures

To avoid developer confusion, we indicate action status codes (application layer) separately from the HTTP status code (networking layer). For example, an HTTP status code of 404 can only mean that the endpoint itself is not found, and cannot be confused with different circumstance where a request is made for a deleted entity. This differs a bit from typical REST pattern established about 20 years ago, but I have seen developers lose time when they mix up networking errors and application logic errors, and this adjustment intends to avoid that.

Responses from POST or PUT requests have a status object indicating success or specifying failure.

Status object format:
```
"status": {
    "code": 101,
    "error_message": "etag conflict"
}
```

Status Codes:
- 0: success, OK
- 100: bad request
- 101: invalid etag (conflict)
- 102: invalid ctag (pagination refresh required)
- 404: entity not found

### Future Enhancements

In a real production environment, all endpoints would be authenticated and served over SSL.

With more time, we might make use of a typed API definition like Protocol Buffers to prevent misuse. Shared Protobuf definitions can be compiled into code for client and server! Providing generated classes for serializing and deserializing messages avoids a lot of boilerplate programming and simple typo mistakes.

The [Create Recording](./recordings-create.md) endpoint currently expects entire files to be uploaded in one network request, and could be enhanced by breaking large files into chunks and uploading individually with partial PUT requests (see https://www.rfc-editor.org/rfc/rfc9110.html#name-partial-put). This strategy could reduce load on server and improve reliability, making recovery easier if any particular network request fails.

A more flexible API is often useful for scaling products, and we could implement by adopting gRPC, GraphQL, or other method-calling framework with more time. Adopting a more modern method-calling pattern could reduce boilerplate (for example, setting up multiple endpoints on server for a REST API can be tedious), improve safety (preventing developer misuse with type-safe method definitions) and efficiency (by reducing number of requests, size of responses).
