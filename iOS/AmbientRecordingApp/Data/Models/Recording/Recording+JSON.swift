import Foundation

/**
 # JSONRecording
 Codable value for `Recording` entity, for building server requests
 */
struct JSONRecording: Codable {
    /// unique identifier for entity (generated by server)
    var id: String
    /// opaque version tag (generated by server)
    var etag: String?
    /// unique identifier for parent entity
    var appointmentID: String?
    /// time when recording began, ISO 8601 Date string
    var start: String?
    /// time when recording ended, ISO 8601 Date string
    var end: String?
    /// duration of recording, in seconds
    var duration: Double?
    /// URL where audio data can be downloaded (generated by server)
    var streamingURL: String?

    /// Translate to json key, if needed
    private enum CodingKeys: String, CodingKey {
        case id
        case etag
        case appointmentID = "appointment_id"
        case start
        case end
        case duration
        case streamingURL = "streaming_url"
    }
}

extension Recording {
    /// Update with properties from JSON returned by server
    func configure(with json: JSONRecording) throws {
        guard let appointmentID = json.appointmentID else {
            throw JSONRecordingError.missingID
        }

        self.recordingID = json.id
        self.appointmentID = appointmentID
        self.etag = json.etag
        self.start = Date.fromISODate(json.start)
        self.end = Date.fromISODate(json.end)
        self.duration = json.duration ?? 0
        self.streamingURL = json.streamingURL
    }

    /// Format JSON representing entity to send to server
    func toJSON() -> JSONRecording {
        JSONRecording(
            id: recordingID,
            etag: etag,
            appointmentID: appointmentID,
            start: start?.ISO8601Format(),
            end: end?.ISO8601Format(),
            duration: duration,
            streamingURL: streamingURL
        )
    }
}

/// Errors that can occur while serializing or deserializing data
enum JSONRecordingError: Error {
    case missingID
}
